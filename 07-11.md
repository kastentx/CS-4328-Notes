## Processes
### States
* new -> ready: 'admits' all resources except CPU
* ready -> running: 'scheduler' puts process in ready queue
* ready <- running: interrupts can move a running process back to ready
* running -> waiting: if IO is needed, process will be put into waiting state
* waiting -> ready: when IO is completed, process will go back into ready queue
* running -> terminated: when exit is encountered, or process is killed

### PCB
* **Process Control Block**
* each process has its own PCB (type of data structure)
  * in C, this will be a `struct`
* contains a pointer, process state, PID, program counter (PC), registers, memory limits (base + limit), list of open files
* _base + limit_ registers let us know the bounds of the memory space for this process

### accounting
* monitoring the resource/hardware usage
* ensures one thing isn't monopolizing a certain resource

### context switch
* when CPU switches from one process to another one
  * _first step:_ save the context from p1 into PCB1
  * _second step:_ load the new context (for p2) from PCB2

## Schedulers
* **Long-term Scheduler** (job scheduler)
  * selects which processes should be brought into the ready queue
  * loads jobs from the disk (job pool) and brings them into main memory
    * will grab a mix of both CPU and IO bound jobs
  * runs less frequently than short-term scheduler
  * **multiprogramming** allows us to grab many jobs at once
    * the number of jobs that can be picked is called the _'degree of multiprogramming'_
* **Short-term Scheduler** (CPU scheduler)
  * selects which process should be executed next and allocates CPU
  * used very frequently (milliseconds)
  * picks highest-priority jobs from the ready queue
* **Medium-term Scheduler**
  * can swap out some partially executed processes from the main memory back into the job pool
  * prevents the CPU from becoming _saturated_

### types of jobs
1. CPU Bound Jobs
  * uses a lot of CPU time
2. IO-Bound Jobs
  * uses a lot of IO

## Creating a Process
* `fork()` system call is used to create a new process
  * returns a `PID` AKA an ID number for the process
    * `PID` of less than 0 indicates some type of error
    * `PID` equal to 0 indicates a _child process_
    * otherwise, a `PID` greater than 0 indicates a _parent process_
      * uses `wait(NULL)` command to wait for child to complete
      * `exit(0)` can be used to exit the program after child processes have completed
* `execlp()` executes a command
  * part of a 'family' of system calls
  * with sample params: `execlp("/bin/ls", "ls", NULL);`
  * nothing in a process _after_ this gets executed.. exits the process
* multiple processes can be created to do multiple things
* there is always a parent process for your program, by default
* after `fork` is run, there will be 2 processes (parent + child)
* to seperate the tasks between processes, use the `PID`
  * board example uses if/else conditions to section off parts of the remaining code
  * 

### creating multiple processes
* different structures/hierarchies can be used
  * multiple siblings, single chain of parent/child, or a mix
* once a new process is created, it is independent (regardless of structure)
* to implement siblings, put another `pid = fork()` and if/else branch inside the parent conditional branch
* code is executed according to the processes selected by the scheduler.. _NOT_ by the order the code is written

## `wait` command
* means the parent process is waiting for the completion of the child process
* `SIGCHLD` signal is generated by the child when complete and sent to parent
  * parent will then release the PID used by the child
* without the `wait` command, _child_ will die while _parent_ still lives
  * the dead child process is called a **Zombie**
    * these are bad, becuase they take up resources and a PID that could be re-used
    * to kill a zombie process, we cannot use the normal 'kill' process
      * normal process is `kill` command (`kill -9 pid`)
    * the parent process must be killed in order to kill any remaining 'zombie children'
      * this will turn the _zombie process_ into an **orphan process**
        * orphans will eventually be 'adopted' by the _init process_