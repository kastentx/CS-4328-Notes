### components
* aplication must request hardware resources from the operating system
* **allocator** allocates things like CPU, mem, IO, file
* a **process** is the execution of a program 
  * if many users are running one program, that program will have many processes
* **controller** decides when to allocate different resources
* **kernel** is the core of the operating system that is running all the time
* **init process** sits on top of the process tree
  * from it, more processes are created further down the tree

### history
* **spooling** is a way to overlap IO from one process while another process is processing
* **multiprocessing** allows multiple processes to be loaded at one time

### systems
* **time-sharing systems** split up cpu time between the different users
* **real-time systems** must respond to outisde stimulus within a deadline
  * _hard_ and _soft_ versions exist, with more and less strict deadlines
* parallel CPUs with a central, shared memory and clock are called a **tightly-coupled parallel system** 
  * connected by a _bus_
* a similar setup with many CPUs that each have their _own_ memory is called a **distributed system** and is **loosely-coupled**
  * connected by a _network_
* if all devices have equal rights, they are **peers**
  * another setup is **master/slave**
* grid systems
* cloud computing

### interrupts
* purpose is to notify the CPU that something has occured
* interrupts are generated by hardware or software **events**
  * hardware - called _interrupt_
  * software - sometimes called _trap_
* dividing by zero and illegal memory access are common errors that 'trap to the kernel'
* data transfer completing is an interrupt that can be generated by hardware
* when an event happens, execution goes to a fixed location
* this location contains the address for the handler routine
* this code executes, handles the event and generates an interrupt
* OS is interrupt-driven, since its behavior changes in reaction to these events/interrupts

### types of IO
* **synchronous IO** blocks execution until IO is completed, and then continues
* **asynchronous IO** continues execution and does not wait for IO to finish

### Device Tables
* devices waiting in line for a resource/device can be stored in a linked list
* **DMA - Direct Memory Access** a faster way to transfer data, using blocks of data that don't interrupt for each byte (once per block)

### Memory
* volatile - registers cache, main memory
* non-volatile - disks

## hardware protection
### Dual Mode
* **supervisor/monitor mode** - priveleged user (represented by a 0 bit)
* **user mode** - rights of a regular user (represented by a 1 bit)
  * user doesn't have rights to set a bit, so unable to change privlege level
* **system calls** are the functions to use the computers services
* **privleged instructions** shouldn't be accessible by regular users
  * things like clearing the memory, disabling interrupts, etc.
  * IO is a priveleged instruction : regular user can only do IO through 'system calls'

### Memory Protection
* users only able to access certain regions of memory
  * should correspond to their programs/processes/jobs
* OS stored in its own region of memory (monitor)
* **base + limit registers** store the addresses of the highest and lowest memory a user can access

### IO Protection
* protected through system calls
  * these are the only methods that users can perform IO through

### CPU Protection
* timer can be implemented to prevent users from exceeding a certain time limit
  * infite loop prevention, etc

**system call**
1. trap to monitor
2. perform I/O
3. return to user

## ch3
## common system components
* Process Management
  * Multiple users = multipe processes that must be managed
    * _Scheduling_ is part of this (when stuff will run)
* Main-Memory Management - controls the volatile memory
* Secondary-Storage Management - handles the non-volatile and disk storage
* I/O management - devices drivers, etc
* File Management - 
* protection system - protection from attacks
* networking - not covered in this class
* command-interpreter system <- we will build one
  * something like a terminal or bash (how a command like `ls` gets interpreted)
  * different than using a GUI which is more user friendly

## OS Services
* Program Execution - the OS handles the running/execution of a program for the user
* I/O operation - system hides the details of the I/O devices 
* file-system manipulation - ability to read/write/create/delete files
* communications - via shared memory or message passing
* error handling

### additional OS services
* resource allocation / accounting - making sure users don't tie up stuff for too long
* protections

### communication models
* **Shared Memory**
  * acts like a mailbox/dropbox
  * users can leave a message in this space, or read one that has been left for them
  * NOTE: only works for multiple users on _one machine_
  * can be more efficient, especially when data being transferred is large
* **Message Passing**
  * user must build a message, then gives it to OS
  * OS sends the message to other user
  * receiving user has to unpack the message and then is able to read it
  * can be used to transfer messages between users on different machines
  * requires large messages to be split up into multiple packets, which can cause slower transfers

## Structure of OS
### simple
* early days of computing
* OS didn't have as many functions
* no structure to them

### layered
* components are divided into different layers
* lowest layer is hardware
* highest layer is applications
* normally, the higher layers call the lower levels
  * it is called an **upcall** when a lower level calls one higher than itself _(not recommended)_
* takes advantage of **information hiding** similar to OOP
  * treats the lower levels as 'black boxes'
  * no need to know how they get their job done, just that they perform a certain function
* layered approach leads to easier debugging
* having too many layers can cause response times to grow

### microkernel
* as name implies, idea is to have a very small kernel
* many additional components exist outside the kernel, in the user space
  * components such as the command-interpreter system..
  * makes it easy to change parts around
* the important components: _process management, memory management, and communication_ are the only ones included in the kernel
* smaller kernel -> easier to troubleshoot, easier to expand upon

### virtual machine
* in a virtual machine, instead of app/OS/hw layers, everything below app is the host machine
  * HW is lowest layer, everything else/above is VM
* creates an illusion, making each user think/feel like they are the only user of a system
* each user has their own independent space (kernel/processes)
  * easier to protect than a non-virtual machine
  * great multitasking capabilities
  * allows hardware to run programs that weren't originally intended for it
* some drawbacks: execution is slower

## module 4 : Processes
* process vs. program
  * program is a set of instructions (static)
  * process is an execution of a program
* as a process executes, it can be in different **states**
  * _new:_ new processes are created from the _init_ process, with a parent/child structure
  * _ready:_ means a process is ready to be run by the CPU, put in the "ready queue" (gets all resources except CPU)
  * _running:_ when CPU is ready, it will run the process (can be moved back into 'ready' state by interrupts)
  * _waiting:_ means process is currently waiting for some or all of its resources (besides the CPU - could be I/O)
  * _terminated:_ a process moves to this state once it has completed execution (or it has been killed)
* **PCB** is a data structure that contains all the information about a process
  * called the _Process Control Block_
  * each process has its own PCB
    * contains a pointer, process state, PID, program counter (PC), registers, memory limits (base + limit), list of open files
* **context switch** is when a CPU switches from one process to another (may be due to an interrupt)
  * when switching, context of P1 gets saved into PCB1 (in memory)
  * new context (P2) gets loaded from PCB2 (also in main memory)
  * this process is treated as an _overhead_ of the OS even though it is essential
    * threads can be used to fill out fewer fields, speeding up the time needed for context switching
    * threads can be created within a process.. save from having to refill out similar fields